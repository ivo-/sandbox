#+TITLE: Exercise 2.2.2
#+OPTIONS: tex:t toc:nil num:nil f:nil todo:nil author:nil email:nil
#+OPTIONS: creator:nil d:nil timestamp:nil

#+STYLE: <style>
#+STYLE: h1.title {text-align: left; margin-left: 3%;}
#+STYLE: p { margin: 0; padding 0; white-space: pre; }
#+STYLE: section {  margin-left: 3%; }
#+STYLE: blockquote { padding: 10px; border-left: 5px silver solid; font-weight:bold; }
#+STYLE: </style>

#+BEGIN_QUOTE
Consider sorting $n$ numbers stored in array $A$ by first finding the
smallest element of $A$ and exchanging it with the element in $A[1]$.
Then find the second smallest element of $A$, and exchange it with
$A[2]$. Continue in this manner for the first $n-1$ elements of $A$.

Write pseudocode for this algorithm, which is known as selection sort.
What loop invariant does this algorithm maintain? Why does it need to
run for only the first $n-1$ elements, rather than for all $n$
elements? Give the best-case and worst-case running times of selection
sort in $\theta$-notation.
#+END_QUOTE

#+HTML: <section>
#+BEGIN_SRC C
SELECTION_SORT(A)
for i = 1 to A.length - 1
  s = i
  for j = i+1 to A.length
    if A[j] < A[s]
      s = j
  A.swap(i, s)
#+END_SRC

*Loop invariant*
Subarray of the first $k=i-1$ elements in A is always sorted.

*Why does it need to run for only the first $n-1$ elements, rather
than for all $n$ elements?*
Last nth iteration in unnecessary. If all elements from subarray
$A[1..n-1]$ are in their places, then A[n] is also in its place.

*Give the best-case and worst-case running times of selection
sort in $\theta$-notation.*

Worst and best case running times are the same $T(n)=\theta(n^2)$.


#+HTML: </section>
