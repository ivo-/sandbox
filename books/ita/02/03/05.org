#+TITLE: Exercise 2.1.5
#+OPTIONS: tex:t toc:nil num:nil f:nil todo:nil author:nil email:nil
#+OPTIONS: creator:nil d:nil timestamp:nil

#+STYLE: <style>
#+STYLE: h1.title {text-align: left; margin-left: 3%;}
#+STYLE: p { margin: 0; padding 0; white-space: pre; }
#+STYLE: section {  margin-left: 3%; }
#+STYLE: blockquote { padding: 10px; border-left: 5px silver solid; font-weight:bold; }
#+STYLE: </style>

#+BEGIN_QUOTE
Referring back to the searching problem (see Exercise 2.1-3), observe that if the
sequence $A$ is sorted, we can check the midpoint of the sequence against $\nu$ and
eliminate half of the sequence from further consideration. The binary search algorithm
repeats this procedure, halving the size of the remaining portion of the
sequence each time. Write pseudocode, either iterative or recursive, for binary
search. Argue that the worst-case running time of binary search is
$\theta(\lg{n})$.
#+END_QUOTE

#+HTML: <section>
#+BEGIN_SRC C
BINARY_SEARCH(A, v, p, q)
m = (p + q)/2

if p == q
  return NIL
if A[m] == v
  return m
if v < A[m]
  return BINARY_SEARCH(A, v, p, m-1)
if v > A[m]
  return BINARY_SEARCH(A, v, m+1, q)
#+END_SRC

Worst case running time is:

$n=p-q+1$
$$ T(n) = \begin{cases}
c          &amp; \text{if } n = 1 \\
T(n/2) + c &amp; \text{if } n > 1
\end{cases} $$

$$ T(n) = \begin{cases}
\theta(1)          &amp; \text{if } n = 1 \\
T(n/2) + \theta(n) &amp; \text{if } n > 1
\end{cases} $$

If we construct recursion tree, we will see that there are $\log{n}-1$
levels in it and each level has cost $n$.

$T(n)=c(\log{n}+1)=c\log{n}+c=\theta(\log{n})$

#+HTML: </section>
