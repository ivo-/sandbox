#+TITLE: Logic programing with Prolog
#+STARTUP: showall

* Resources
** Prolog A Tutorial Introduction

   James Lu
   Jerud J. Mead

   Computer Science Department
   Bucknell University
   Lewisburg, PA 17387

* Summary

  Logic programming is a programming paradigm based on mathematical logic. In
  this paradigm the programmer specifies relationships among data values (this
  constitutes a logic program) and then poses queries to the execution
  environment in order to see whether certain relationships hold.

  Putting this in another way, a logic program, through explicit facts and
  rules, defines a base of knowledge from which implicit knowledge can be
  extracted.

  The Prolog execution environment doesnâ€™t so much "compute" an answer, it
  "deduces" an answer from the relation definitions at hand. Rather than being
  given an expression to evaluate, the Prolog environment is given an expression
  which it interprets as a question:

    For what parameter values does the expression evaluate to true?

  Prolog has no types. Though the basic elements of Prolog are typeless, most
  implementations have been enhanced to include character and integer values and
  operations. Also, Prolog has mechanisms built in for describing tuples and
  lists.

  *constants* - identifiers that start with lower-case letters.
  *variables* - identifiers that start with upper-case letters.

* Prolog

  Prolog is referred to as a *declarative language*. A Prolog program consists
  of *facts* and *rules* which serve to define *relations* aka *predicates*.
  Execution engine is a mechanism for recursively extracting sets of data values
  implicit in the facts and rules of a program. It is based on *unification* and
  *resolution*.

** Facts and Rules

   Both of these statements are used for describing *predicates* and can be
   combined in predicate definition.

   *Fact* is statement, consisting of an *identifier*(predicate name) and *tuple
   of constants*, and sets that tuple *satisfies* unconditionally the predicate.

     parent(lisp, clojure). % Note the lower case used for constants.

   *Rule* is statement which gives ~conditions under which a tuple of constants
   satisfy the predicate~. In a sense a ~fact is just a special case of rule~,
   where condition is always satisfied by some chosen tuple of constants.

   *Atom* is a *predicate* followed by a tuple of *terms*, where both
   *constants* and *variables* are terms. Every *fact* is an *atom* and *rule*
   *consists from a group of atoms. If a tuple satisfies the predicate of the
   *atom, we say that atom is true.

     *head* :- *body*           % Building blocks of a rule.
     *Atom* :- *Atom1*, *Atom2* % If Atom[1..n] is true then Atom is also true.

     tedge(Node1,Node2) :-
      edge(Node1,SomeNode),
      edge(SomeNode,Node2).

   *Recursive rules*

** Queries

   We can send queries to predicates to extract some implicit information,
   defined by facts and rules.

     ?- parent(c, lisp). % Check if constants satisfy the predicate.
     ?- parent(c, X).    % Request possible values for variables.
     ?- parent(X, c).    %
     ?- parent(X, Y).    &
