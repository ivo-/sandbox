# Talk to values, imputabilty, avoiding global state. Stefan knows it, but
# others don't and it's exciting to find out as use. I saw in many projects
# managing global state... isn't it all we fight against :) Lecture for good
# functional design. Small pure functions and state layer.
#
# Anketa: kursove, regexp, concurency, so on
#
# Make lectures plan for 2013
#
# Какво аз намирам в clojure: кулутура(без гл стейт, values), concurrency, lisp,
# repl, good decisions, хора(лицата)
#
# - Hello. And little about Clojure and environment.
# - Emacs setup.
# - The magic about Lisp and lambda calculus. And what this will bing you, how
#    your thinking should be changed. Philosophical.
# - How programs should be structured with pure functions, values, state layer.
# - Interactive development and what it gives you.
# - Clojure community and smart people around it. Batteries included stack,
#    core.logic, core.async(in concurrency), core.typed, leiningen, core.match.
# - ClojureScript and the smart ideas behind it.

# More text on presentations people seems to use them to learn.

#
# Lisp slides and terminology. Functional programing basics.
#
# Modeling data well in Clojure puts the focus on values (and particularly
# composite values), natural identifiers(auto generated), and sets and map.
#
# Synthetic identifiers are by definition artifacts of incidental complexity.
#
# If we have cycles in order, our data to stay value, we must add indirection
# layer that we can use to avoid cycles.(build dom tree)
#
# We must fully embrace programing with values, to get the most out of
# Clojure.
#
# Natural identifiers are opposed to synthetic or surrogate identifiers, where
# the latter are usually strings or an artificially generated number, akin to
# sequences or auto increments in databases or object references themselves in
# most object-oriented languages. Thus, synthetic identifiers are by definition
# artifacts of incidental complexity. Keep as little data for data as possible,
# and let it describe itself.
#
# We should work with the real abstracitons cells and neighbors not indexes,
# rows or columns.
#
# Sometimes changing data structures is enough to simplify the problem. By
# proper choosing our data structures we can produce more generic code.
#
# Implement some sort relaying on not natural identifiers with Clojure relaying
# on them and show how different it is. Something like Game of life example but
# easier to understand. viscous.
#
# Avoid dealing or keeping identifiers to data. Deal with data using composition
# of higher order functions and let data identify itself.
#
# Generally, when you find the code you are writing painful or awkward, you are
# most certainly fighting the language, working against its grain. Chances are
# that in such cases you’ll be able to find a more pleasant solution by
# rethinking your data structures. As Brooks’s quote said, code follows from
# data modeling, so pleasant Clojure code flows from good data representation,
# which so often implies natural composite identifiers, sets, and maps.
#
# People seems to forget about sets.
#
# Give example how we can abstract by adding more higher order functions and
# compare this to inheritance. Solutions that can be easily abstracted are often
# functional than imperative solutions. Data structures should be abstracted
# from solution and it will be good. Single thing should be abstracted with
# single function.
#
# Give example for data transformation in solving problem. Functional is data
# transformation, imperative is data synthesis.

# About global state and sierra's workflow.
#
#
# Zippers and task to realize tree with zipper. AVL zipper tree.
# https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj
#
# How beautiful is that we can interchange (delay) and (future) and map and
# record, ...
# Example with: JSON and url reading
#
# Identity-state time model seems to have all the benefits from values and
# immutability, but is capable to replace mutable state.
# Clojure's approach on concurrency eliminates a whole category of bugs related
# to concurrent programing, but doesn't lower the possibilities.
# Reference types represent identities and data structures states.

# When changing atoms or other reference types, don't apply modifications one by
# one, this will allow other threads to see identity in inconsistent state. Use
# functions composition instead. Don't violate principles.
