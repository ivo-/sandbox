# Talk to values, imputabilty, avoiding global state. Stefan knows it, but
# others don't and it's exciting to find out as use. I saw in many projects
# managing global state... isn't it all we fight against :) Lecture for good
# functional design. Small pure functions and state layer.
#
#
# Make lectures plan for 2013
#
# Какво аз намирам в clojure: кулутура(без гл стейт, values), concurrency, lisp,
# repl, good decisions, хора(лицата)
#
# - Hello. And little about Clojure and environment.
# - Emacs setup.
# - The magic about Lisp and lambda calculus. And what this will bing you, how
#    your thinking should be changed. Philosophical.
# - How programs should be structured with pure functions, values, state layer.
# - Interactive development and what it gives you.
# - Clojure community and smart people around it. Batteries included stack,
#    core.logic, core.async(in concurrency), core.typed, leiningen, core.match.
# - ClojureScript and the smart ideas behind it.

# More text on presentations people seems to use them to learn.

#
# Lisp slides and terminology. Functional programing basics.
#
# Modeling data well in Clojure puts the focus on values (and particularly
# composite values), natural identifiers(auto generated), and sets and map.
#
# Synthetic identifiers are by definition artifacts of incidental complexity.
#
# If we have cycles in order, our data to stay value, we must add indirection
# layer that we can use to avoid cycles.(build dom tree)
#
# We must fully embrace programing with values, to get the most out of
# Clojure.
#
# Natural identifiers are opposed to synthetic or surrogate identifiers, where
# the latter are usually strings or an artificially generated number, akin to
# sequences or auto increments in databases or object references themselves in
# most object-oriented languages. Thus, synthetic identifiers are by definition
# artifacts of incidental complexity. Keep as little data for data as possible,
# and let it describe itself.
#
# We should work with the real abstracitons cells and neighbors not indexes,
# rows or columns.
#
# Sometimes changing data structures is enough to simplify the problem. By
# proper choosing our data structures we can produce more generic code.
#
# Implement some sort relaying on not natural identifiers with Clojure relaying
# on them and show how different it is. Something like Game of life example but
# easier to understand. viscous.
#
# Avoid dealing or keeping identifiers to data. Deal with data using composition
# of higher order functions and let data identify itself.
#
# Generally, when you find the code you are writing painful or awkward, you are
# most certainly fighting the language, working against its grain. Chances are
# that in such cases you’ll be able to find a more pleasant solution by
# rethinking your data structures. As Brooks’s quote said, code follows from
# data modeling, so pleasant Clojure code flows from good data representation,
# which so often implies natural composite identifiers, sets, and maps.
#
# People seems to forget about sets.
#
# Give example how we can abstract by adding more higher order functions and
# compare this to inheritance. Solutions that can be easily abstracted are often
# functional than imperative solutions. Data structures should be abstracted
# from solution and it will be good. Single thing should be abstracted with
# single function.
#
# Give example for data transformation in solving problem. Functional is data
# transformation, imperative is data synthesis.

# About global state and sierra's workflow.
#
#
# Zippers and task to realize tree with zipper. AVL zipper tree.
# https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj
#
# How beautiful is that we can interchange (delay) and (future) and map and
# record, ...
# Example with: JSON and url reading
#
# Identity-state time model seems to have all the benefits from values and
# immutability, but is capable to replace mutable state.
# Clojure's approach on concurrency eliminates a whole category of bugs related
# to concurrent programing, but doesn't lower the possibilities.
# Reference types represent identities and data structures states.

# When changing atoms or other reference types, don't apply modifications one by
# one, this will allow other threads to see identity in inconsistent state. Use
# functions composition instead. Don't violate principles.

# Modern garbage collection implementations can enable programs to outperform
# alternatives written using manual memory management in many contexts; and,
# each time a new garbage collector implementation or optimization is added to
# the JVM, every program everywhere benefits from it without any involvement
# from individual programmers. The same dynamic has played out with Clojure’s
# STM.

# Clojure's STM is optimistically trying to reorder concurrent change operations
# so they are applied serially.

# Overtone and clojure bands.
# Links for more on each presentation.
# Talk a lot for architecture on functional program.

# Edit deref retry section and add (let solution) this will generally improve performance.
#
# Example when shared resource(log writer) is stored into agent and agent
# semantics are used to coordinate access to it. fire-and-forget persistence mechanism

# Show finite state machine example using atoms, but simplified.
# Scheme in clojure macro example.

# Learning Clojure: next show various libs.

# About advantages from laziness. Give concatenate example and how we can choose
# to do elegant solutions because of laziness.

# core.logic to parse presentations code.

# Clojure differences from Scala, Java, Groovy, ...
# Clojure is really simple and small

# First class functions as a first rule when you need an abstraction.

# Show some interesting macros from clojure.core and discus how macros are
# useful for extending language and how they make possible small core and much
# of the syntax to be generated using them.

# Lecture:
# - show contents
# - show interface that we will use
# - discuss best practices, advantages, give examples

# all the actions that get sent to any agent using send are run in a threadpool with a couple more threads than the physical number of processors. this causes them to run closer to the cpu's full capacity. if you make 1000 calls using send you don't really incur much switching overhead, the calls that cant be processed immediately just wait until a processor becomes available. If they block then the thread pool can run dry

# NOTE: Not new just expandable thread pool.
# when you use send-off a new thread is created for each call. if you send-off 1000 functions the ones that cant be processed immediately still wait for the next available processor and they may incur the extra overhead of starting a thread if the "send-off threadpool" happens to be running low . its ok if the threads block because each task (potentially) gets a dedicated thread.
# MORE: http://tech.puredanger.com/2010/06/08/clojure-agent-thread-pools/

# ClojureScript example stack lecture.
# Web example stack lecture.

# For example, the effect of a changed macro definition will not be seen until
# code which uses the macro has been recompiled
# Changes to methods of a defrecord or deftype will not have any effect on
# existing instances of that type.
# Show sierra's workflow.

# Code is structured just in namespaces and vars.

# Constructor for state instead of global state.
# Pass state to operations.
# Tools.analyzer for macroexpand.

# TODO: On lazyness how collection is iterated once not for every operation.
# Reducers after laziness.(@skanev)
# Clojure compilation and compilers before talking to macros or at the same time?
#
# Thanks to macros haskell style pattern matching is a library, Prolog like
# relational programming is a library.

# core.async is a good demonstration of the power of the macro facilities that a
# Lisp has to offer: while most other language core.async does things that would
# require changes to the language, in a Lisp it is possible to implement these
# as a library using macros.

# About EDN.

# Core.async and Rich intended it for control flow(quote) but it can be very
# pleasant way to do parallel work. Even in JS to avoid blocking the main
# thread.

# Learn from Rich Hickey texts(clojure.org) and mention rationale before each
# lecture. Structure them that way.

# Protocols and example how we can remove big if-s like these we do in Scheme
# for example.

# More than anything with Clojure I’ve come to appreciate the data-centric
# approach to building software. This is deserving of a much longer and more
# exploratory post someday but I can now see how Java locks your data away in
# boxes and makes you use keys (and write key factories and key adapters and key
# factory bridge adapters) to get it back out again. Like I said, need to write
# this up in more detail.
#
# Clojure just passes that data around without all these unnecessary
# abstractions. It is based on data transformations.

# Core.async still makes better code, we will have to use global state to sync
# async operations in JS but with channels we can avoid this. Make example and
# mention FRP.

# What makes scheme unpractical? How Clojure solves this?
# Lisp is so powerful that problems which are technical issues in other
# programming languages are social issues in Lisp.

# Reader checks for duplicates.
# (hash-map (atom nil) {}
# (atom nil) {})
# {(new-state) {}
# (new-state) {}}

# pr-str, read-string notes
# Core.async ngnix example with workers and do this with treads and blocking
# queues.
#
# Анкета: kursove, regexp, concurency, so on
#
# In clojure data is on the pedestal. It has powerful standard lib to work with
# them. Event the code is data.

# Any problem in computer science can be solved with another level of indirection. -- David Wheeler


# Our intellectual powers are rather geared to master static relations and that
# our powers to visualize processes evolving in time are relatively poorly
# developed. For that reason we should do (as wise programmers aware of our
# limitations) our utmost to shorten the conceptual gap between the static
# program and the dynamic process, to make the correspondence between the
# program (spread out in text space) and the process (spread out in time) as
# trivial as possible.
#
#       Dijkstra (1968) "A Case against the GO TO Statement"

# Processes over time to abstractions that makes the code look like it is
# executed in the single point of time. It is what core.async tends to do or
# react.

# Future of JS frameworks as notes.

# Clojure developers are always pragmatic and use the cool stuff that's already
# done: JVM, Closure, Go rutines, ReactJS

# OOP programmer will get data, move it to 3-4-5 classes introducing state in
# all of them and work with those abstractions. FP programmer will just work
# with the raw data and Clojure is especially powerful in that case.

# Why to use compiled to JS language as CLJS:
#  - Produces highly effective code.
#  - Gets out of your way if you want to do something preferment.
#  - Clojure on the clinet.
#  - repl, core.async, OM, core.logic, core.match
