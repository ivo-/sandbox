# Talk to values, imputabilty, avoiding global state. Stefan knows it, but
# others don't and it's exciting to find out as use. I saw in many projects
# managing global state... isn't it all we fight against :) Lecture for good
# functional design. Small pure functions and state layer.
#
# Anketa: kursove, regexp, concurency, so on
#
# Make lectures plan for 2013
#
# Какво аз намирам в clojure: кулутура(без гл стейт, values), concurrency, lisp,
# repl, good decisions, хора(лицата)
#
# - Hello. And little about Clojure and environment.
# - Emacs setup.
# - The magic about Lisp and lambda calculus. And what this will bing you, how
#    your thinking should be changed. Philosophical.
# - How programs should be structured with pure functions, values, state layer.
# - Interactive development and what it gives you.
# - Clojure community and smart people around it. Batteries included stack,
#    core.logic, core.async(in concurrency), core.typed, leiningen, core.match.
# - ClojureScript and the smart ideas behind it.

# More text on presentations people seems to use them to learn.

#
# Lisp slides and terminology. Functional programing basics.
#
# Modeling data well in Clojure puts the focus on values (and particularly
# composite values), natural identifiers(auto generated), and sets and map.
#
# Synthetic identifiers are by definition artifacts of incidental complexity.
#
# If we have cycles in order, our data to stay value, we must add indirection
# layer that we can use to avoid cycles.(build dom tree)
#
# We must fully embrace programing with values, to get the most out of
# Clojure.
#
# Natural identifiers are opposed to synthetic or surrogate identifiers, where
# the latter are usually strings or an artificially generated number, akin to
# sequences or auto increments in databases or object references themselves in
# most object-oriented languages. Thus, synthetic identifiers are by definition
# artifacts of incidental complexity. Keep as little data for data as possible,
# and let it describe itself.
#
# We should work with the real abstracitons cells and neighbors not indexes,
# rows or columns.
#
# Sometimes changing data structures is enough to simplify the problem. By
# proper choosing our data structures we can produce more generic code.
#
# Implement some sort relaying on not natural identifiers with Clojure relaying
# on them and show how different it is. Something like Game of life example but
# easier to understand. viscous.
#
# Avoid dealing or keeping identifiers to data. Deal with data using composition
# of higher order functions and let data identify itself.
#
# Generally, when you find the code you are writing painful or awkward, you are
# most certainly fighting the language, working against its grain. Chances are
# that in such cases you’ll be able to find a more pleasant solution by
# rethinking your data structures. As Brooks’s quote said, code follows from
# data modeling, so pleasant Clojure code flows from good data representation,
# which so often implies natural composite identifiers, sets, and maps.
#
# People seems to forget about sets.
#
# Give example how we can abstract by adding more higher order functions and
# compare this to inheritance. Solutions that can be easily abstracted are often
# functional than imperative solutions. Data structures should be abstracted
# from solution and it will be good. Single thing should be abstracted with
# single function.
#
# Give example for data transformation in solving problem. Functional is data
# transformation, imperative is data synthesis.

# About global state and sierra's workflow.
#
#
# Zippers and task to realize tree with zipper. AVL zipper tree.
# https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj
#
# How beautiful is that we can interchange (delay) and (future) and map and
# record, ...
# Example with: JSON and url reading
#
# Identity-state time model seems to have all the benefits from values and
# immutability, but is capable to replace mutable state.
# Clojure's approach on concurrency eliminates a whole category of bugs related
# to concurrent programing, but doesn't lower the possibilities.
# Reference types represent identities and data structures states.

# When changing atoms or other reference types, don't apply modifications one by
# one, this will allow other threads to see identity in inconsistent state. Use
# functions composition instead. Don't violate principles.

# Modern garbage collection implementations can enable programs to outperform
# alternatives written using manual memory management in many contexts; and,
# each time a new garbage collector implementation or optimization is added to
# the JVM, every program everywhere benefits from it without any involvement
# from individual programmers. The same dynamic has played out with Clojure’s
# STM.

# Clojure's STM is optimistically trying to reorder concurrent change operations
# so they are applied serially.

# Overtone and clojure bands.
# Links for more on each presentation.
# Talk a lot for architecture on functional program.

# Edit deref retry section and add (let solution) this will generally improve performance.
#
# Example when shared resource(log writer) is stored into agent and agent
# semantics are used to coordinate access to it. fire-and-forget persistence mechanism

# Show finite state machine example using atoms, but simplified.
# Scheme in clojure macro example.

# Learning Clojure: next show various libs.

# About advantages from laziness. Give concatenate example and how we can choose
# to do elegant solutions because of laziness.

# core.logic to parse presentations code.

# Clojure differences from Scala, Java, Groovy, ...
# Clojure is really simple and small

# First class functions as a first rule when you need an abstraction.

# Show some interesting macros from clojure.core and discus how macros are
# useful for extending language and how they make possible small core and much
# of the syntax to be generated using them.

# Lecture:
# - show contents
# - show interface that we will use
# - discuss best practices, advantages, give examples
